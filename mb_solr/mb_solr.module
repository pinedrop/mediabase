<?php
/**
 * @file
 * Mediabase module that interfaces with solr to provide a collection view
 * as well as facet hierarchies on both collection and non-search pages.
 *
 */
 
 /**
  * Implemente hook_menu
  */
function mb_solr_menu() {
  $items = array();
  // Return results of facet search in gallery form
  $items['services/facet/%/%'] = array(
    'title' => 'Facet search results',
    'description' => 'Return raw HTML for mbase facet search results',
    'page callback' => 'mb_solr_facet_search',
    'page arguments' => array(2,3),
    'access callback' => TRUE,
  );
  return $items;
}

/**
 * Implements of hook_apachesolr_index_document_build
 * Adds collection parent gids of a team
 *
 * @param ApacheSolrDocument $document
 * @param object $entity
 * @param string $entity_type
 * @param string $env_id
 *   The machine name of the environment.
 */
function mb_solr_apachesolr_index_document_build(ApacheSolrDocument $document, $entity, $entity_type, $env_id) {
   if (! isset($entity->type) || ! in_array($entity->type, array('video','audio'))) {
      return;
   }
   $parent_group_gid = !empty($entity->group_audience['und']) ? $entity->group_audience['und'][0]['gid'] : null;
   if (!empty($parent_group_gid)) {
      $gids=array($parent_group_gid);
      $parent_group = og_get_group('group',$parent_group_gid);
      $group_node = node_load($parent_group->etid);
      if ($group_node->type == 'team') { 
         $coll_ancestor_node = get_collection_ancestor_node($group_node);
         $ancestor_group = og_get_group('node',$coll_ancestor_node->nid);
         $gids[] = $ancestor_group->gid;
      }
      foreach ($gids as $gid) {
         $document->addField('im_collection_gid', $gid);
      }
   }
}

/**
 * Implements hook_apachesolr_search_page_alter
 */
function mb_solr_apachesolr_search_page_alter(&$build, $search_page) {
  // add js for js tree on all pages so sub collection hierarchy can appear on non-search pages.
  $jsscripts = drupal_add_js(NULL, NULL, NULL);
  if (!array_key_exists('sites/all/modules/mediabase/mb_solr/js/mb_solr.js', $jsscripts)) { 
    drupal_add_js('sites/all/modules/mediabase/mb_solr/js/mb_solr.js', array('cache' => FALSE));
    //drupal_add_js('sites/all/modules/mediabase/mb_solr/js/jquery.jstree.js', array('cache' => FALSE));
  } 
  // Remove title from homepage
  if($search_page['page_id'] == 'homepage') {
    drupal_set_title('');
  }
}


/*
 * mb_solr_apachesolr_query_alter():
 * 
 *    Implements hook_apachesolr_query_alter
 *    adds collection GIDs to solr Queries when there is a im_collection_gid filter that is defined in the search page for the new collection page
 *    see:  /admin/config/search/apachesolr/search-pages/collection_home/edit
 * 
 *    Also adds a random sort filter as described by http://realize.be/random-results-apache-solr-and-drupal
 * 
 */
 
function mb_solr_apachesolr_query_alter($query) {
   $path = $query->getPath(); // only alter query for collection pages. Solr re-indexing page urls begin with collection
   if ($path == "homepage/") {
     $query->setSolrsort('ds_created', 'desc'); // sort by date created so there can be pagination
     // Random Sort filter
     /*
     $seed = rand(0, 9999);
     $sort_name = "random_$seed";
     $order = (rand(0, 1) == 0) ? 'asc' : 'desc';
     $query->setAvailableSort($sort_name, array('title'=> 'random', 'default' => 'asc'));
     $query->setSolrsort($sort_name, $order); 
      */
   }
   if (preg_match("/^collection\//",$path) && !preg_match("/admin\/config/", $path))  {
    // Collection id (gid) filter
     $gid_filters = $query->getFilters('im_collection_gid');
     foreach ($gid_filters as $idx => $gid_filter) {
          $value = $gid_filter['#value'];
          if (is_numeric($value) ) { // we've likely got a gid as the value already
             continue;
          }
          // we've likely got an alias as the filter value
          $alias_path = "collection/$value";
          $node_path = drupal_lookup_path('source', $alias_path);
          if ( empty($node_path) ) {
            // redirect to page not found to avoid error when non-existent collection is searched. (2014-01-21)
            drupal_not_found();
            module_invoke_all('exit');
            exit();
            // continue;
          }
          $parts = explode('/', $node_path);
          $nid = array_pop( $parts );
          $group = og_get_group('node', $nid);
          $query->removeFilter('im_collection_gid', $value);
          $query->addFilter('im_collection_gid', $group->gid);
     }
     
     $gid_filters = $query->getFilters('im_collection_gid');
     
     $query->setSolrsort('ds_created', 'desc'); // sort by date created so there can be pagination
     /*
      * // Random Sort filter
     $seed = rand(0, 9999);
     $sort_name = "random_$seed";
     $order = (rand(0, 1) == 0) ? 'asc' : 'desc';
     $query->setAvailableSort($sort_name, array('title'=> 'random', 'default' => 'asc'));
     $query->setSolrsort($sort_name, $order);
      */ 
    
   }
}

/**
*   mb_solr_apachesolr_process_results():
* 
*     Implementation of hook_apachesolr_process_results
*     Add thumbnail url to the result items
**/
function mb_solr_apachesolr_process_results(&$results, DrupalSolrQueryInterface $query) {
   $path = $query->getPath();
   if ($path == "homepage/" || (preg_match("/^collection\//",$path) && !preg_match("/admin\/config/", $path)))  {
     foreach ( $results as $idx => $item ) {
        $bundle = $item['bundle'];
        $media_field_table = "field_data_field_$bundle";
        $entryid_column = "field_$bundle" . "_entryid";
        $entity_id = $item['fields']['entity_id'];
        
        if ('video' == $bundle) {
           $query = "SELECT kaltura_thumbnail_url
           FROM {field_data_field_video} 
           JOIN {node_kaltura} ON field_video_entryid = kaltura_entryid
           WHERE entity_id = :etid";
        }
        else if ('audio' == $bundle) {
           $query = "SELECT kaltura_thumbnail_url
           FROM {field_data_field_audio} 
           JOIN {node_kaltura} ON field_audio_entryid = kaltura_entryid
           WHERE entity_id = :etid";
        }
        
        $res = db_query($query, array(':etid' => $entity_id) );
        $col = $res->fetchCol();
        $thumb_url = array_shift($col);
        $results[$idx]['thumb_url'] = $thumb_url;
     }
   }
}

/**
* Implements hook_theme().
*/

function mb_solr_theme($existing) {
   return array(
     'search_results__apachesolr_search__collection_home' => array(
         'variables' => array('search_results' => NULL, 'module' => array()),
         ),
     'search_results__apachesolr_search__homepage' => array(
         'variables' => array('search_results' => NULL, 'module' => array()),
         ),
      'mediabase_thumbnail' => array(
        'template' => 'mediabase_thumbnail',
        'path' => drupal_get_path('module', 'mediabase') . '/templates',
        'variables' => array('entity' => NULL, 'coll' => NULL,),
        ),
     );
}  

/**
 * Search results theming function just creates mark up for items in the collect
 * This is included in the node display through mb_solr_node_view (below).
 */
function theme_search_results__apachesolr_search__collection_home(&$vars) {
  global $base_path;
  $output = '<div class="shanti-gallery">';
  $nid = $vars['results'][0]['fields']['entity_id'];
  $node = node_load($nid);
  $coll = get_collection_ancestor_node($node);
  if($coll) {
      $coll->url = $base_path . drupal_get_path_alias('node/' . $coll->nid);
  }
  foreach ($vars['results'] as $k => $v) {
    $output .=  mb_solr_make_teaser($v, $coll);
  }
  $output .= '</div>' . $vars['pager'];
  return $output;
}

function theme_search_results__apachesolr_search__homepage(&$vars) {
  global $base_path;
  drupal_set_breadcrumb(array(l('','home')));
  $output = '<div class="shanti-gallery">';
  $nid = $vars['results'][0]['fields']['entity_id'];
  $node = node_load($nid);
  $coll = get_collection_ancestor_node($node);
  if($coll) {
      $coll->url = $base_path . drupal_get_path_alias('node/' . $coll->nid);
  }
  foreach ($vars['results'] as $k => $e) {
    $output .=  mb_solr_make_teaser($e, $coll);
  }
  $output .= '</div>' . $vars['pager'];
  return $output;
}

/**
 *  Function called by theming function above to create the markup for a a/v "teaser" in the standard Mediabase model from the home page.
 *    (Note: check to see how the home page creates its teasers for a function that might return the bulk of the markup)
 */
function mb_solr_make_teaser($entity, $coll) {
  $mbpath = drupal_get_path('module', 'mediabase');
  $entity['thumb_url'] = (isset($entity['thumb_url'])) ? $entity['thumb_url'] : url($mbpath, array('absolute' => true)) . '/images/generic-video-thumb.jpg';
  $html = theme('mediabase_thumbnail', array('entity' => $entity, 'coll' => $coll));
  return $html;
}

/**
 * Implements hook_node_view:
 *    Call the search page to get the list of a collections a/v items and adds these to the node's display.
 *    Because they come from the search page, these results are linked to the subcollection facet block which is made to appear on the node page through the block admin interface.
 *    Thus, when a facet is chosen, it filters the results on the collections home page
 * 
 *  NOTE: the path 'collection/%' is set by the Path module's URL Alias setting on the configuration page
 */

function mb_solr_node_view($node, $view_mode, $langcode) {
  if($node->type == 'collection') {
    $alias = str_replace('collection/', '', drupal_get_path_alias(current_path()));
    module_load_include('inc','apachesolr','apachesolr_search.pages');
    $search_page = apachesolr_search_custom_page('collection_home','', $alias);
    $node->content['collcontent'] = array( 
      '#markup' => '<div id="mb-solr-collection-content" class="block-inner clearfix">' . 
        '<h2 class="block-title">Media in ' . $node->title . '</h2>' . 
        '<div id="mb_solr_items" class="content clearfix">' . drupal_render($search_page['search_results']) . '</div></div>',
      '#weight' => 45,  // set high weight so it appears after the body's description
    );
  } else {
    module_load_include('inc','apachesolr','apachesolr_search.pages');
    $cpage = apachesolr_search_custom_page('core_search');
  }
}

/**
 * API Function called through /services/facet/%/% returns JSON information for a facet filtered search
 *  A call of clear/all will clear the facet search and return all results for the page
 */
function mb_solr_facet_search($facet_name, $fid, $pgname = "homepage", $collid = FALSE) {
  // TODO: Need to make this work for collection search pages and Ajax as well
  // Facet info
  $searcher = 'apachesolr@solr';
  $adapter = facetapi_adapter_load($searcher);
  $facet = facetapi_facet_load($facet_name, $searcher);
  $term = taxonomy_term_load($fid);
  // Load Search page and search
  $search_page = apachesolr_search_page_load('homepage');
  $conditions = apachesolr_search_conditions_default($search_page);
  $conditions['fq'][] = ($fid == 'clear') ? array() : array("$facet_name:$fid");
  $keys = '';
  $results = apachesolr_search_search_results($keys, $conditions, $search_page);
  //dpm($search_page, 'search_page');
  // Create HTML Array of results themed as thumbnails
  $html = array(
    '#prefix' => '<article><div class="region region-content"><div class="content">',
    '#suffix' => '</div></div></article>',
  );
  
  if($fid != 'clear') {
    $html['h1'] = array(
        '#markup' => t('<h3>Faceted Search on @TERM in @SCOPEs</h3>', array('@TERM' => $term->name, '@SCOPE' => $facet['label'])),
    );
  // If clearing a facet search add back in the block that belong on the page
  } 
  /* Doesn't work
  else {
    global $theme_key;
    $all_regions = system_region_list($theme_key);
    module_load_include('inc', 'block', 'block.admin');
    $blocks = block_admin_display_prepare_blocks($theme_key);
    dpm($blocks, 'before');
    $blocks = array_filter($blocks, function ($item) use (&$data) {
        return ($item['region'] == 'content' && (strpos($item['pages'], 'homepage')));
    });
    foreach($blocks as $n => $block) {
      $html['blocks' . $n] = array(
        '#markup' => render($block),
      );
    }
    dpm(array($blocks, $html));
  }
   */
  foreach($results as $key => $item) {
    $node = node_load($item['node']->entity_id);
    $coll = get_collection_ancestor_node($node);
    //$coll = 'no coll';
    $html['content']['#markup'] .= mb_solr_make_teaser($item, $coll);
  }
  $facet_data = mb_solr_get_facet_data($facet_name);
  // TODO: need to theme the results into HTML output
  $output = array(
    'items' => $results,
    'count' => count($results),
    'facets' => $facet_data,
    'html' => render($html),
  );
  drupal_json_output($output);
}

/**
 * Get the facet data for a programmatic search from mb_solr_facet_search
 * Called from the facet service function mb_solr_facet_search() to return json facet search data
 */
function mb_solr_get_facet_data($facet_name) {
  // TODO: Check if this will work on collection page searches or if it always searches all.
  $searcher = 'apachesolr@solr';
  $adapter = facetapi_adapter_load($searcher);
  $facet = facetapi_facet_load($facet_name, $searcher);
  $adapter->processFacets();
  $processor = $adapter->getProcessor($facet_name);
  $facet = $adapter->getFacet($facet);
  $realm = facetapi_realm_load('ajax');
  $facet_build = $facet->build($realm, $processor);
  $facet_build = $facet_build[$facet_name][$facet_name];
  $facet_data = array();
  mb_solr_process_facet_data($facet_name, $facet_build, $facet_data);
  return $facet_data;
}

/**
 * Iterate through facet results and process into easily readable data (filter out unnecessary fields)
 */
function mb_solr_process_facet_data($facet_name, $facet_data, &$info_out) {
  if(isset($facet_data['#items'])) {
    foreach($facet_data['#items'] as $key => $item) {
      $info_out[] = array(
        'facet' => $facet_name,
        'fid' => $item['#indexed_value'],
        'ftitle' => $item['#markup'],
        'count' => $item['#count'],
      );
      if(is_array($item['#item_children']) && count($item['#item_children']) > 0) {
        mb_solr_process_facet_data($facet_name, $item['#item_children'], $info_out);
      }
    } 
  } else {
    foreach($facet_data as $key => $item) {
        $info_out[] = array(
        'facet' => $facet_name,
        'fid' => $item['#indexed_value'],
        'ftitle' => $item['#markup'],
        'count' => $item['#count'],
      );
      if(is_array($item['#item_children']) && count($item['#item_children']) > 0) {
        mb_solr_process_facet_data($facet_name, $item['#item_children'], $info_out);
      }
    }
  }
}

function mb_solr_facetapi_realm_info() {
  return array(
    'ajax' => array(
      'label' => t('Ajax'),
      'sortable' => FALSE,
      'weight' => -10,
      'default widget' => 'mb_solr_ajax_facets',
      'element type' => 'links',
      //'settings callback' => 'facetapi_block_realm_settings',
      'description' => t('formatter for Ajax calls'),
    ),
  );
}

/*
 *  Implements hook_facetapi_widget: 
 *     Creates a widget option in the facet display page called 'Mediabase Select Tree' that calls the MBSolrFacetapiWidgetMbSolrTree class
 */
function mb_solr_facetapi_widgets() {
  return array(
    'mb_solr_facet_tree' => array(
      'handler' => array(
        'label' => t('Mediabase Select Tree'),
        'class' => 'MbSolrFacetapiWidgetMbSolrTree',
        'query types' => array('term', 'date'),
      ),
    ),
    'mb_solr_ajax_facets' => array(
      'handler' => array(
        'label' => t('Mediabase Ajax Facets'),
        'class' => 'MbSolrFacetapiWidgetAjax',
        'query types' => array('term', 'date'),
      ),
    ),
  );
}

/** hook implemented by facetapi_bonus */
/**function mb_solr_facet_items_alter(&$build, &$settings) {
  //dpm($build, 'build in hook');
  foreach($build as $key => &$item) {
    $item['#theme'] = 'mb_solr_node';
  }
}**/

function mb_solr_facetapi_empty_behaviors() {
  return array(
    'none' => array(
      'handler' => array(
        'label' => t('Do not display facet'), 
        'class' => 'FacetapiEmptyBehaviorNone',
      ),
    ),
    'name' => array(
      'handler' => array(
        'label' => t('Do not display facet'), 
        'class' => 'FacetapiEmptyBehaviorText',
      ),
    ),
  );
}

/*
 * MbSolrFacetapiWidgetMbSolrTree: This extends the FacetapiWidgetLinks class found in the facetapi module
 *    It only makes two changes to the execute() and buildListItems() function, changing the path to the current path of the collection.
 */
class MbSolrFacetapiWidgetMbSolrTree extends FacetapiWidgetLinks {
   /**
    * Modifies the standard facet tree by changing the path from the standard search path to the collection or current path
    */
  public function execute() {
    $elements = &$this->build[$this->facet['field alias']];
    foreach($elements as $n => &$element) {
      $element['#path'] = current_path();
    }
    // Hack to not show Collections root item at top of tree
    // TODO: This should be generalized to see if Kmap Root Id field is used and if this TID matches that Kmaps TID. Then don't show.
    if(isset($elements[4]) && $elements[4]['#markup'] == "Collections") {
      $elements = $elements[4]['#item_children'];
    }
    // Sets each item's theme hook, builds item list.
    $this->setThemeHooks($elements);
    //dpm($elements, 'elements');
    $items = $this->buildListItems($elements);
    
    $elements = array(
      '#theme' => 'item_list',
      '#items' => $items,
      'title' => 'mb-solr-facet-tree',
      '#attributes' => $this->build['#attributes'],
    );
    //dpm($elements);
  }
  
  function buildListItems($build) {
    $settings = $this->settings->settings;
    
    // Initializes links attributes, adds rel="nofollow" if configured.
    $attributes = ($settings['nofollow']) ? array('rel' => 'nofollow') : array();
    $attributes += array('class' => $this->getItemClasses());
    
    // Builds rows.
    $items = array();
    foreach ($build as $value => $item) {
      $row = array('class' => array());
      // Initializes variables passed to theme hook.
      $variables = array(
        'text' => $item['#markup'],
        'path' => current_path(),
        'count' => $item['#count'],
        'options' => array(
          'attributes' => $attributes,
          'html' => $item['#html'],
          'query' => $item['#query'],
        ),
      );
      // Add facet name and ID to elements data
      if(isset($item['#query']['f'][0])) {
        $temp = explode(':', $item['#query']['f'][0]);
        $fname = $temp[0];
        $row['data-fname'] = $fname;
        $row['data-fid'] = $item['#indexed_value'];
      }
      // Adds the facetapi-zero-results class to items that have no results.
      if (!$item['#count']) {
        $variables['options']['attributes']['class'][] = 'facetapi-zero-results';
        // For facets with no results, make link new filter with that facet only
        $query = $variables['options']['query']['f'];
        $newquery = array_pop($query);
        $variables['options']['query']['f'] = array($newquery);
      }

      // Add an ID to identify this link.
      $variables['options']['attributes']['id'] = drupal_html_id('facetapi-link');

      // If the item has no children, it is a leaf.
      if (empty($item['#item_children'])) {
        $row['class'][] = 'leaf';
      }
      else {
        // If the item is active or the "show_expanded" setting is selected,
        // show this item as expanded so we see its children.
        if ($item['#active'] || !empty($settings['show_expanded'])) {
          //$row['class'][] = 'expanded';  // ignore expanded for use with fancy tree
          $row['children'] = $this->buildListItems($item['#item_children']);
        }
        else {
          $row['class'][] = 'collapsed';
        }
      }

      // Gets theme hook, adds last minute classes.
      $class = ($item['#active']) ? 'facetapi-active' : 'facetapi-inactive';
      $variables['options']['attributes']['class'][] = $class;
      // Themes the link, adds row to items.
      $row['data'] = theme($item['#theme'], $variables) ;
      $items[] = $row;
    }
    return $items;
  }
}

class MbSolrFacetapiWidgetAjax extends FacetapiWidgetLinks {
   /**
    * Modifies the standard facet tree by changing the path from the standard search path to the collection or current path
    */
  public function execute() {
    $elements = &$this->build[$this->facet['field alias']];
    foreach($elements as $n => &$element) {
      $element['#path'] = current_path();
    }
    $items = $this->buildListItems($elements);
    $elements = array(
      '#items' => $items,
    );
  }
  
  function buildListItems($build) {
    $items = array();
    foreach ($build as $value => $item) {
      
      $items[$value] = $item;
    }
    return $items;
  }
}

